= Bill Dueber's DynamicField Solr Config
Bill Duebebr <bill@dueber.com>
:toc:

== A fully dynamic solr configuration I don't hate

This is a solr configuration designed to make it easy to both have
fully dynamic fields without sacrificing readability of the field names.

It strives to be simple to use while fulfilling the following:

* **Simple names**. A solr document will have bare names for
 the stored fields, like `mainauthor` (single value) or
 `title_a` (array value).

* **Indexed fields expose their type**.
With the default setup,
a test field ends in '_t', an integer in '_i', and a field suitable
for faceting in '_f'.

* **A single field sent to Solr can result in multiple stored/indexed
fields**. Only send as much data as you need to; let Solr do the work
of copying it out to appropriate fields.


== Using the dynamic field definitions


A constructed field name has two to four parts, separated by underscores.

- The _basename_. This is the descriptive field name (title, author, etc.)
- The _fieldtype suffix_.  There is a mapping of fieldtype suffixes to fieldtypes
  in the `generate_dfields.rb` script. Some map to multiple indexed types, and
  adding to that list is as easy as editing the top of the file.
- An optional `_stored` (that literal string), indicating that the item should
  be stored.
- An optional `_single` (again that exact string) indicating that this is a single-valued
  field instead of a multi-valued field.
  
If `_stored` and `_single` are both present, they need to be in that order. 

[cols=".<6m,.^1,.^1,.^1,.<10", options="header", width=100]
.Examples of dynamic field results
|===
|Fieldname | Stored  | Indexed Name/type| Arity | Notes

|title_t
|n/a
|text
|Mult
|Default is unstored array

|author_e_stored_single
|author
|author_e/exactish
|Single
| `stored` must come before `single`

|rawrecord
|rawrecord
|n/a
|Single
|Anything not matches is just stored

|product_t_stored
|product_a
|product_t/text
|Mult
|Stored arrays end in `_a`

|subject_tsearchf_stored
|subject_a
a|subject_t/text +
subject_tl/text_leftjustified +
subject_tp/text_nostem +
subject_f/string +
|Mult
|Configuration file allows multi-expanse

|emoji_a
|emoji_a
|n/a
|Mult
|Fields that end in `_a` are stored as an array without indexing

|title_a_f_single
|?
|?
|?
| Hmmm. Better test this.
|===


=== Fields meant for sorting

Two fieldname suffixes are special-cased: _ssort_ for strings meant as a sort key, and
_isort_ for integers (longs, actually, under the hood) meant as a sort key. The idea
is that you don't have to separately store a sort field as, say, `title_sort_str` just
so you can see what it is when debugging.

Examples:

  - `title_ssort` will just produce the string field `title_ssort`; no changes
  - `title_ssort_stored` will produce `title_ssort`, but also a stored string called
    `title_sort` (note _sort_ instead of _ssort_)
  - Similarly, `age_isort_stored` will produce both `age_isort` (indexed long) and 
    `age_sort` (stored string)


=== Limitations

All indexed types are multivalued under the hood::
This means that if you define two fields:
* `fulltext_tsearch_single`
* `fulltext_t_single`

...then you'll have overloaded `fulltext_t`, since the `_tsearch` type produces, among
  other fields a `_t`.

The result is that you will end up with multiple values if you send
data for both `fulltet_tsearch_single` and `fulltet_t_single`, even though both individual fields are
single-valued. There's no good solution except to be aware of what indexed fields you're actually producing

There's no good way to know what's actually been indexed::
This is a limitation of dynamic fields in
   general, but my schema exacerbates the problem because there's not a one-to-one mapping
   between the field name sent to solr (`title_t_stored_single`) and the actual fields solr has
   (`title_t` and `title_a` in this case)


=== Why this works

I take advantage of a couple peculiarities of solr:

- There's no penalty (that I can find, anyway) for having a stored, unindexed
  field and an unstored, indexed field as opposed to a single field
  that is both stored and indexed
- Dynamic fields can be totally ignored (neither indexed nor stored)
  but still be available for copyFields
- Searching a multi-valued field with one value is no different than searching a
  single-valued field. This allows me to "reuse" indexed field types
  while allowing the field name actually passed to be used as a gatekeeper
  for non-multi fields (e.g., if you send multiple values to a single-valued
  field, it'll still blow up real nice).

== Field types

There are several field type definitions in the [`conf/schema`](https://github.com/billdueber/solr6_test_conf/tree/master/test_core/conf/schema) directory that 
might have some advantages over the stock Solr types. Some highlights:

Pre-tokenization manipulation:: Some common and/or important text strings are hard
to search on, like _&_, C++_ and _Aâ™®_. The [common text chain](https://github.com/billdueber/solr6_test_conf/blob/master/test_core/conf/schema/basic_text_chain.xml) I use does reasonably substitutions 
of these before tokenization, so you can muck with punctuation terms before throwing them out. I also take that opporntunity to do unicode normalization.

text::  A basic analyzed text type, built for unicode support (for those of us that have to deal with
many languages) and using unicode folding (lowercasing), normalization, and the ICU tokenizer. Forms the basis of all `text_leftjustified` and `exactish`

text_leftjustified:: The `text_leftjustified` type will only match a phrase query
at the start of a string.

exactish:: A replacement of sorts for the String type, for exact matching without
taking into account case or most punctuation.

numericID:: A relatively specialized type that allows you to extract numeric strings
from text, demanding that they be of a certain length (or length range). Currently set up, essentially, for ISSN extraction, but can be adapted for any data where the numeric ID you're looking for might be buried in other text.

Special library types:: ...for us library-types. This repo includes a .jar file and fieldTypes that
do normalization on ISBNs and LCCNs, so you know index-time and query-time changes are 
equivalent. 







